<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Live Webcam Inference</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100%;
            background: #f0f0f0;
            font-family: Arial, sans-serif;
            background-color: black;
        }

        #fullscreenCanvas {
            flex-grow: 1;
            width: auto;
            height: auto;
            max-width: 100%;
            max-height: 100%;
            margin: auto;
            display: block;
        }

        #MessageDisplayContainer {
            text-align: center;
            background: #ffffff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        #Message {
            margin-top: 20px;
            font-size: 18px;
        }

        #toggleCameraButton {
            margin: 10px auto;
            padding: 10px 20px;
            background-color: #00FF00;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        #toggleCameraButton:hover {
            background-color: #00cc00;
        }
    </style>
</head>

<body>
    <button id="toggleCameraButton">Switch Camera</button>
    <canvas id="fullscreenCanvas"></canvas>
    <div id="MessageDisplayContainer">
        <div id="Message">Running Live Inference...</div>
    </div>

    <script>
        const mesageResetTimer_Threshold = 15;
        let mesageResetTimer_count = 0;
        const fullscreenCanvas = document.getElementById("fullscreenCanvas");
        const fullscreenCtx = fullscreenCanvas.getContext("2d");
        const threshold = 0.4; // Confidence threshold
        let model, webcamStream, videoElement;
        let currentDeviceIndex = 0;
        let devices = [];

        async function loadModel() {
            const availableProviders = ['webgpu', 'webgl', 'wasm']; // Ordered by preference
            for (const provider of availableProviders) {
                try {
                    const session = await ort.InferenceSession.create("yolov8nq.onnx", {
                        executionProviders: [provider]
                    });
                    console.log(`Using ${provider} as the backend`);
                    return session;
                } catch (error) {
                    console.warn(`${provider} backend not available:`, error);
                }
            }
            throw new Error('No available backend found.');
        }

        async function runModel(model, imageData) {
            const tensor = new ort.Tensor(Float32Array.from(imageData), [1, 3, 640, 640]);
            const feeds = { images: tensor };
            const output = await model.run(feeds);
            return output["output0"].data;
        }

        function process_output(output, img_width, img_height) {
            let boxes = [];
            const num_boxes = 8400;
            for (let index = 0; index < num_boxes; index++) {
                const objness = output[4 * num_boxes + index]; // Objectness score
                if (objness < threshold) continue;

                const xc = output[index];
                const yc = output[num_boxes + index];
                const w = output[2 * num_boxes + index];
                const h = output[3 * num_boxes + index];

                const x1 = (xc - w / 2);
                const y1 = (yc - h / 2);
                const x2 = (xc + w / 2);
                const y2 = (yc + h / 2);

                boxes.push([x1, y1, x2, y2, objness]);
            }

            boxes = boxes.sort((box1, box2) => box2[4] - box1[4]);
            const result = [];
            while (boxes.length > 0) {
                result.push(boxes[0]);
                boxes = boxes.filter(box => iou(boxes[0], box) < 0.7); // Apply NMS
            }
            return result;
        }

        function iou(box1, box2) {
            return intersection(box1, box2) / union(box1, box2);
        }

        function union(box1, box2) {
            const [box1_x1, box1_y1, box1_x2, box1_y2] = box1;
            const [box2_x1, box2_y1, box2_x2, box2_y2] = box2;
            const box1_area = (box1_x2 - box1_x1) * (box1_y2 - box1_y1);
            const box2_area = (box2_x2 - box2_x1) * (box2_y2 - box2_y1);
            return box1_area + box2_area - intersection(box1, box2);
        }

        function intersection(box1, box2) {
            const [box1_x1, box1_y1, box1_x2, box1_y2] = box1;
            const [box2_x1, box2_y1, box2_x2, box2_y2] = box2;
            const x1 = Math.max(box1_x1, box2_x1);
            const y1 = Math.max(box1_y1, box2_y1);
            const x2 = Math.min(box1_x2, box2_x2);
            const y2 = Math.min(box1_y2, box2_y2);
            return (x2 - x1) * (y2 - y1);
        }

        async function getCurrentLocation() {
            return new Promise((resolve, reject) => {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const { latitude, longitude } = position.coords;
                            resolve({ latitude, longitude });
                        },
                        (error) => {
                            switch (error.code) {
                                case error.PERMISSION_DENIED:
                                    reject("User denied the request for Geolocation.");
                                    break;
                                case error.POSITION_UNAVAILABLE:
                                    reject("Location information is unavailable.");
                                    break;
                                case error.TIMEOUT:
                                    reject("The request to get user location timed out.");
                                    break;
                                default:
                                    reject("An unknown error occurred.");
                                    break;
                            }
                        }
                    );
                } else {
                    reject("Geolocation is not supported by this browser.");
                }
            });
        }

        async function requestLocationPermission() {
            const Result = document.getElementById("Message");
            try {
                const location = await getCurrentLocation();
                Result.textContent = `Potholes Detected At [ Latitude: ${location.latitude}, Longitude: ${location.longitude} ]`;
            } catch (error) {
                Result.textContent = `Error: ${error}`;
            }
        }

        function drawDetections(image, boxes) {
            fullscreenCtx.clearRect(0, 0, fullscreenCanvas.width, fullscreenCanvas.height);
            fullscreenCtx.drawImage(image, 0, 0, fullscreenCanvas.width, fullscreenCanvas.height);
            fullscreenCtx.strokeStyle = "#fc0303"; // Orange = #fc8c03 , Green  = #00FF00 ,
            fullscreenCtx.lineWidth = 2;
            fullscreenCtx.font = "12px Arial";
            mesageResetTimer_count += 1;
            if (mesageResetTimer_count >= 200) {
                mesageResetTimer_count = 21;
            }

            boxes.forEach(([x1, y1, x2, y2, prob]) => {
                mesageResetTimer_count = 0;
                fullscreenCtx.strokeRect(x1 * (fullscreenCanvas.width / 640), y1 * (fullscreenCanvas.height / 640), (x2 - x1) * (fullscreenCanvas.width / 640), ((y2 - y1) * (fullscreenCanvas.height / 640)));
                fullscreenCtx.fillStyle = "#fc0303";
                const text = `Pothole (${prob.toFixed(2)})`;
                const textWidth = fullscreenCtx.measureText(text).width;
                fullscreenCtx.fillRect(x1 * (fullscreenCanvas.width / 640), (y1 - 25) * (fullscreenCanvas.height / 640), textWidth + 3, 15);
                fullscreenCtx.fillStyle = "#FFFFFF";
                fullscreenCtx.fillText(text, (x1 + 2) * (fullscreenCanvas.width / 640), (y1 - 5) * (fullscreenCanvas.height / 640));
                requestLocationPermission();
            });
            if (mesageResetTimer_count == mesageResetTimer_Threshold) {
                const Result = document.getElementById("Message");
                Result.textContent = `Running Live Inference...`;

            }
        }

        async function startWebcam(deviceId) {
            if (webcamStream) {
                webcamStream.getTracks().forEach(track => track.stop());
            }
            webcamStream = await navigator.mediaDevices.getUserMedia({ video: { deviceId: deviceId } });
            videoElement = document.createElement('video');
            videoElement.srcObject = webcamStream;
            videoElement.onloadedmetadata = () => {
                videoElement.play();
                fullscreenCanvas.width = videoElement.videoWidth;
                fullscreenCanvas.height = videoElement.videoHeight;
                detectFrame();
            };
        }

        async function detectFrame() {
            fullscreenCtx.drawImage(videoElement, 0, 0, fullscreenCanvas.width, fullscreenCanvas.height);
            const imageData = fullscreenCtx.getImageData(0, 0, fullscreenCanvas.width, fullscreenCanvas.height);
            const processedData = preprocess(imageData);
            const output = await runModel(model, processedData);
            const boxes = process_output(output, fullscreenCanvas.width, fullscreenCanvas.height);
            drawDetections(videoElement, boxes);
            requestAnimationFrame(detectFrame);
        }

        function preprocess(imageData) {
            const canvas = document.createElement("canvas");
            canvas.width = 640;
            canvas.height = 640;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(videoElement, 0, 0, 640, 640);
            const scaledImageData = ctx.getImageData(0, 0, 640, 640);
            const data = scaledImageData.data;
            const floatArray = new Float32Array(640 * 640 * 3);
            for (let i = 0; i < 640 * 640; i++) {
                floatArray[i] = data[i * 4] / 255.0; // R
                floatArray[i + 640 * 640] = data[i * 4 + 1] / 255.0; // G
                floatArray[i + 2 * 640 * 640] = data[i * 4 + 2] / 255.0; // B
            }
            return floatArray;
        }

        async function getConnectedDevices(type) {
            const devices = await navigator.mediaDevices.enumerateDevices();
            return devices.filter(device => device.kind === type);
        }

        async function initializeWebcam() {
            devices = await getConnectedDevices('videoinput');
            if (devices.length > 0) {
                await startWebcam(devices[currentDeviceIndex].deviceId);
            } else {
                console.error("No webcam devices found.");
            }
        }

        async function switchCamera() {
            currentDeviceIndex = (currentDeviceIndex + 1) % devices.length;
            await startWebcam(devices[currentDeviceIndex].deviceId);
        }

        document.getElementById("toggleCameraButton").addEventListener("click", switchCamera);

        (async () => {
            model = await loadModel();
            await initializeWebcam();
        })();
    </script>
</body>

</html>
